<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <!--Import Google Icon Font-->
    <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
    <!--Import materialize.css-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css">


    <!--Let browser know website is optimized for mobile-->
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />

    <!-- CSS -->
    <link rel="stylesheet" href="css/style.css">

    <title>Visão Geral</title>
</head>

<body>

    <!-- nav bar -->
    <ul id="dropdown1" class="dropdown-content">
        <li><a href="VisaoGeralHTTP.html">Visão Geral</a></li>
        <li><a href="cache.html">Cache HTTP</a></li>
        <li><a href="cookiesHTTP.html">Cookies HTTP</a></li>
        <li><a href="evolucaoHTTP.html">Evolução do HTTP</a></li>
        <li><a href="mesagensHTTP.html">Mensagens HTTP</a></li>
        <li><a href="sessãoHTTP.html">Uma sessão típica em HTTP</a></li>
        <li><a href="genConect.html">Gerenciamento de conexões</a></li>
        <li><a href="controleAce.html">Controle de Acesso</a></li>
        <li><a href="preBusca.html">Controlando a pré-busca</a></li>

    </ul>

    <div class="navbar-fixed">
        <nav>
            <div class="nav-wrapper grey darken-4">
                <a href="index.html" class="brand-logo "><img src="imgs/logoMDN.png" alt=""
                        style="width: 63px; margin-left: 10px;"></a>
                <ul class="right hide-on-med-and-down">
                    <li><a href="#">Login</a></li>
                    <li><a href="rest.html">rest</a></li>
                    
                    <!-- Dropdown Trigger -->
                    <li><a class="dropdown-trigger" href="#!" data-target="dropdown1">Tutoriais<i
                                class="material-icons right">arrow_drop_down</i></a></li>
                </ul>
            </div>
        </nav>
    </div>


    <!-- banner -->
    <div class="col s12 l12 m12 grey-text text-darken-4 right-align" id="bannerNome">
        <div class="container">
            <b>HTTP ou Hypertext Transfer Protocol</b>
        </div>
    </div>

    <!-- Breadcrumbs -->
    <nav>
        <div class="nav-wrapper grey darken-4 truncate">
            <div class="col s12" id="breadC" style="font-weight: 200; margin-left: 20px;">
                <a href="https://developer.mozilla.org/pt-BR/docs/Web" class="breadcrumb">Tecnologia para
                    desenvolvedores web</a>
                <a href="index.html" class="breadcrumb">HTTP</a>
                <a href="#!" class="breadcrumb">Visão Geral</a>
            </div>
        </div>
    </nav>

    <!-- Conteudo -->
    <div class="row">
        <!-- Menu lateral -->


        <div class="container">
            <!-- CONTEUDO -->
            <div id="cont">
                <p>HTTP é um protocolo (protocol) que permite a obtenção de recursos, tais como documentos HTML. É a
                    base de qualquer troca de dados na Web e um protocolo cliente-servidor, o que significa que as
                    requisições são iniciadas pelo destinatário, geralmente um navegador da Web. Um documento completo é
                    reconstruído a partir dos diferentes sub-documentos obtidos, como por exemplo texto, descrição do
                    layout, imagens, vídeos, scripts e muito mais.</p>
                <img class="responsive-img" src="imgs/FetchingHTTP.png">
                <p>Clientes e servidores se comunicam trocando mensagens individuais (em oposição a um fluxo de dados).
                    As mensagens enviadas pelo cliente, geralmente um navegador da Web, são chamadas de solicitações
                    (requests), ou também requisições, e as mensagens enviadas pelo servidor como resposta são chamadas
                    de respostas (responses).</p>
                <img class="responsive-img" src="imgs/HTTP & layers.png">
                <p>Projetado no início da década de 1990, o HTTP é um protocolo extensível que evoluiu ao longo do
                    tempo. É um protocolo de camada de aplicação que é enviado sobre TCP, ou em uma conexão TCP
                    criptografada com TLS, embora qualquer protocolo de transporte confiável possa, teoricamente, ser
                    usado. Devido à sua extensibilidade, ele é usado para não apenas buscar documentos de hipertexto,
                    mas também imagens e vídeos ou publicar conteúdo em servidores, como nos resultados de formulário
                    HTML (veja os elementos <html> e <form>). O HTTP também pode ser usado para buscar partes de
                        documentos para atualizar páginas da Web sob demanda.</p>
                <div class="divider"></div>
                <h3>Componentes de sistemas baseados em HTTP</h3>
                <p>O HTTP é um protocolo cliente-servidor: as requisições são enviados por uma entidade, o
                    agente-usuário (ou um proxy em nome dele). A maior parte do tempo, o agente-usuário é um navegador
                    da Web, mas pode ser qualquer coisa, como por exemplo um robô que rastreia a Web para preencher e
                    manter um índice de mecanismo de pesquisa.

                    Cada requisição individual é enviada para um servidor, que irá lidar com isso e fornecer um
                    resultado, chamado de resposta. Entre a solicitação e a resposta existem várias entidades,
                    designadas coletivamente como proxies, que executam operações diferentes e atuam como gateways
                    (intermediários) ou caches, por exemplo.
                </p>
                <img class="responsive-img" src="imgs/Client-server-chain.png">
                <p>Na realidade, existem muitos outros computadores entre o navegador e o servidor que está tratando a
                    requisição: existem roteadores, modems e muito mais. Graças ao modelo de camadas da Web (layers),
                    essas funcionalidades estão escondidas nas camadas de rede e transporte, respectivamente. O HTTP
                    está no topo da camada de aplicação. Apesar de ser importante diagnosticar problemas de
                    conectividade, os layers abaixo da camada de aplicação são irrelevantes para a descrição do HTTP.
                </p>
                <h4>Cliente: o agente-usuário</h4>
                <p>O user-agent é qualquer ferramenta que age em nome do usuário. Essa função é predominantemente
                    realizada pelo navegador Web; algumas poucas exceções são programas usados por engenheiros e
                    desenvolvedores Web para depurar as suas aplicações.</p>
                <p>O navegador é sempre a entidade que inicia as requisições. Nunca é o servidor (embora alguns
                    mecanismos tenham sido adicionados ao longo dos anos para simular mensagens iniciadas pelo
                    servidor).</p>
                <p>Para mostrar uma página Web, o navegador envia uma requisição para buscar o documento HTML da página.
                    Ele então realiza uma análise sintática desse arquivo, buscando requisições adicionais
                    correspondentes a scripts de execução, informações de layout (CSS) para apresentação e subrecursos
                    contidos na página (geralmente imagens e vídeos). Depois o navegador interpreta esses recursos para
                    mostrar ao usuário o documento completo, a página Web. Scripts executados pelo navegador podem
                    buscar mais recursos em fases subsequentes e o navegador atualiza a página Web de acordo.</p>
                <p>Uma página Web é um documento de hipertexto. Isso significa que algumas partes do texto mostrado são
                    links (vínculos com outras páginas ou recursos da Web), os quais podem ser ativados (normalmente
                    pelo clique do mouse) para buscar uma nova página, permitindo ao usuário redirecionar seu
                    agente-usuário e navegar pela internet. O navegador traduz esses endereços em requisições HTTP e
                    depois interpreta as respostas HTTP para mostrar ao usuário uma resposta transparente.</p>
                <h4>O servidor de páginas Web</h4>
                <p>Do outro lado do canal de comunicação está o servidor que serve o documento requisitado pelo usuário.
                    Um servidor se apresenta virtualmente apenas como uma máquina: isto porque o servidor pode ser uma
                    coleção de servidores dividindo a carga (através de uma técnica chamada balanceamento de carga) ou
                    também como um programa complexo que acessa outros servidores (como um cache, um servidor de banco
                    de dados, servidores de e-commerce, etc.), gerando todo ou parte do documento solicitado.</p>
                <p>Um servidor não é necessáriamente apenas uma máquina, mas vários servidores podem estar hospedados na
                    mesma máquina. Com o HTTP/1.1 e o cabeçalho Host, eles podem até compartilhar o mesmo endereço IP.
                </p>
                <h4>Proxies (ou representantes)</h4>
                <p>Entre o navegador Web e o servidor, vários computadores e máquinas transmitem as mensagens HTTP.
                    Devido a estrutura em camadas da pilha Web, a maioria dessas máquinas operam em alguma das camadas:
                    de transporte, de rede ou física, sendo transparente na camada da aplicação HTTP, e potencialmente
                    exercendo um grande impacto na performance. Essas máquinas que operam na camada de aplicação são
                    normalmente conhecidas como proxies (ou representantes, ou procuradores, etc). Eles podem ser
                    transparentes ou não (alterações nas requisições não passam por eles), e podem desempenhar várias
                    funções:</p>
                <ul>
                    <li>cacheamento (o cache pode ser público ou privado, como o cache dos navegadores)</li>
                    <li>filtragem (como um scanner de antivírus, controle de acesso, etc)</li>
                    <li>balanceamento de carga (para permitir que vários servidores possam responder a diferentes
                        requisições)</li>
                    <li>autenticação (para controlar quem tem acesso aos recursos)</li>
                    <li>autorização (para controlar quem tem acesso a determinada informação)</li>
                    <li>registro de informação (permite o armazenamento de informações de histórico)</li>
                </ul>
                <h2 class="right-align">Aspectos básicos do HTTP</h2>
                <h4>HTTP é simples</h4>
                <p>Mesmo com mais complexidade introduzida no HTTP/2.0 por encapsular mensagens HTTP em quadros
                    (frames), o HTTP foi projetado para ser simples e legível às pessoas. As mensagens HTTP podem ser
                    lidas e entendidas por qualquer um, provendo uma maior facilidade para desenvolvimento e testes, e
                    reduzir a complexidade para os estudantes.</p>
                <h4>HTTP é extensível</h4>
                <p>Introduzidos no HTTP/1.0, os cabeçalhos HTTP fazem com que este protocolo seja fácil para estender e
                    usá-lo para experimentos. Novas funcionalidades podem até ser introduzidas pelo simples acordo entre
                    um cliente e um servidor sobre a nova semântica de um cabeçalho.</p>
                <h4>HTTP não tem estado, mas tem sessões</h4>
                <p>HTTP é sem estado: não existe uma relação entre duas requisições sendo feitas através da mesma
                    conexão. Isso traz um problema imediato para usuários que interagem com algumas páginas de forma
                    coerente, por exemplo, usando um carrinho de compras de e-commerces*. Mas como o fundamento básico
                    do HTTP é não manter estados, cookies HTTP permitem que as sessões tenham estados. Usando a
                    extensibilidade dos cabeçalhos, os cookies são adicionados ao fluxo do HTTP, permitindo que a
                    criação de sessão em cada requisição HTTP compartilhem o mesmo contexto, ou o mesmo estado.</p>
                <h4>HTTP e conexões</h4>
                <p>Uma conexão é controlada na camada de transporte, e portanto fundamentalmente fora do controle do
                    HTTP. Entretanto o HTTP não requer que o protocolo de transporte utilizado seja baseado em conexões,
                    só requer que seja confiável ou não perca mensagens (sem pelo menos apresentar erros). Dentre os
                    dois protocolos de transporte mais comuns na internet, o TCP é confiável e o UDP não. Portanto, o
                    HTTP utiliza o padrão TCP, que é baseado em conexão, mesmo que nem sempre seja obrigatório o uso de
                    uma conexão.</p>
                <p>No protocolo HTTP/1.0 uma conexão TCP era aberta para cada par de requisição/resposta trocada,
                    introduzindo duas grandes falhas: abrir uma conexão requer várias viagens de ida/volta de mensagens,
                    e portanto é lento, mas se torna mais eficiente quando mensagens são enviadas em maior número ou
                    maior frequência: "conexões quentes" são mais eficientes que "conexões frias" (que envia poucas
                    mensagens ou com baixa frequência).</p>
                <p>Para contornar essas falhas, o protocolo HTTP/1.1 introduziu o conceito de linhas de produção (ou
                    pipelining) — que se provou difícil de ser implementado — e conexões persistentes: as conexões TCPs
                    feitas embaixo, podem ser parcialmente controladas usando o cabeçalho HTTP Connection. O HTTP/2.0
                    foi mais além, multiplexando várias mensagens através de uma única conexão, ajudando a manter a
                    conexão mais quente, e mais eficiente.</p>
                <p>Experimentos estão sendo feitos para projetar um protocolo de transporte mais adequado para o HTTP.
                    Por exemplo, a Google está fazendo testes com o QUIC que é construído sobre o UDP para prover um
                    protocolo de transporte mais confiável e eficiente.</p>
                <div class="divider"></div>
                <h2>O que pode ser controlado pelo HTTP?</h2>
                <p>A natureza extensível do HTTP tem permitido mais controle e funcionalidade para a internet, ao longo
                    do tempo. Cache e autenticação são funcionalidades suportadas desde o início da história do HTTP. A
                    habilidade de relaxar as restrições na origem, em contraste, foi adicionada nos anos 2010s.</p>
                <p>Aqui está uma lista de funcionalidades comuns, controláveis com HTTP:</p>
                <ul>
                    <li><b>Cache</b></br>
                        A forma como documentos são cacheados pode ser controlada pelo HTTP. O servidor pode instruir
                        proxies, e clientes, ao que cachear e por quanto tempo. O cliente pode instruir proxies de cache
                        intermediários a ignorar o documento armazenado.</li>
                    <li><b>Relaxamento das restrições na origem</b></br>
                        Para prevenir bisbilhoteiros e outros invasores de privacidade, os navegadores reforçam
                        estritamente a separação dos sites Web. Somente páginas de mesma origem podem acessar todas as
                        informações de uma página Web. Apesar dessa restrição ser um fardo grande aos servidores, os
                        cabeçalhos HTTP podem relaxar essa separação estrita no lado dos servidores, permitindo que um
                        documento ser composto por várias fontes de informação em outros domínios (e pode até ter razões
                        específicas de segurança para se fazer isso), como um tecido de retalhos.</li>
                    <li><b>Autenticação</b></br>
                        Algumas páginas podem ser protegidas para que apenas usuários específicos possam acessá-la.
                        Autenticação básica pode ser provida pelo HTTP, usando tanto o cabeçalho WWW-Authenticate e
                        similares, quanto configurando uma sessão específica usando cookies HTTP.</li>
                    <li><b>Proxy e tunelamento</b></br>
                        Servidores e/ou clientes estão frequentemente localizados em intranets e escondem seu verdadeiro
                        endereço IP aos outros. Requisições HTTP recorrem aos proxies para contornar essa barreira na
                        rede. Mas nem todos os proxies são proxies HTTP. O protocolo SOCKS, por exemplo, opera em um
                        nível mais baixo. Outros protocolos, como ftp, podem ser tratados por esses proxies.</li>
                    <li><b>Sessões</b></br>
                        Usando os cookies HTTP, permite que você crie vincule às requisições o estado do servidor. Isso
                        cria as sessões, apesar do protocolo HTTP básico não manter estado. Isso é útil não só para os
                        carrinhos de compras de e-commerces, mas também para qualquer site que permita customização das
                        respostas a nível de usuário.</li>
                </ul>
                <div class="divider"></div>
                <h2>Fluxo HTTP</h2>
                <p>Quando o cliente quer comunicar com um servidor, este sendo um servidor final ou um proxy, ele
                    realiza os seguintes passos:</p>
                <p><b>1º passo</b></p>
                <p>Abre uma conexão TCP: A conexão TCP será usada para enviar uma requisição, ou várias, e receber uma
                    resposta. O cliente pode abrir uma nova conexão, reusar uma conexão existente, ou abrir várias
                    conexões aos servidores.</p>
                <p><b>2º passo</b></p>
                <p>Envia uma mensagem HTTP: mensagens HTTP (antes do HTTP/2.0) são legíveis às pessoas. Com o HTTP/2.0,
                    essas mensagens simples são encapsuladas dentro de quadros (frames), tornando-as impossíveis de ler
                    diretamente, mas o princípio se mantém o mesmo.</p>
                <img src="imgs/Screenshot_2.png" alt="" class="responsive-image">
                <p><b>3º passo</b></p>
                <p>Lê a resposta do servidor:</p>
                <img src="imgs/http2.png" alt="" class="responsive-image">
                <p><b>4º passo</b></p>
                <p>Fecha ou reutiliza a conexão para requisições futuras.</p>
                <p>Se a linha de montagem (pipelining) estiver ativada, várias requisições podem ser enviadas sem que a
                    primeira resposta seja totalmente recebida. A linha de montagem HTTP se provou difícil de ser
                    implementada nas redes existentes, onde peças antigas de software coexistem com versões modernas. A
                    linha de montagem HTTP tem sido substituída no HTTP/2.0 com multiplexação mais robusta de
                    requisições dentro de um quadro (frame).</p>

                <div class="divider"></div>
                <h2>Mensagens HTTP</h2>
                <p>HTTP/1.1 e mensagens mais antigas HTTP são legíveis às pessoas. No HTTP/2.0, essas mensagens são
                    embutidas numa nova estrutura binária, um quadro, permitindo otimizações como compressão de
                    cabeçalhos e multiplexação. Mesmo se somente parte da mensagem HTTP original for enviada nessa
                    versão do HTTP, a semântica de cada mensagem permanece inalterada e o cliente reconstitui
                    (virtualmente) a requisição HTTP/1.1 original. É portanto útil entender as mensagens HTTP/2.0 no
                    formato da versão HTTP/1.1.</p>
                <p>Existem dois tipos de mensagens, requisições e respostas, cada uma com seu próprio formato.</p>
                <h4>Requisições</h4>
                <p>Exemplo de uma requisição HTTP:</p>
                <img src="imgs/HTTP_Request.png" alt="" class="responsive-image">
                <p>As requisições consistem dos seguintes elementos:</p>
                <ul>
                    <li>Um método HTTP, geralmente é um verbo como GET, POST, DELETE, PUT, etc, ou um substantivo como
                        OPTIONS ou HEAD que define qual operação o cliente quer fazer. Tipicamente, um cliente que pegar
                        um recurso (usando GET) ou publicar dados de um formulário HTML (usando POST), embora mais
                        operações podem ser necessárias em outros casos.</li>
                    <li>O caminho do recurso a ser buscado; a URL do recurso sem os elementos que são de contexto, por
                        exemplo sem o protocolo protocol (http://), o domínio domain (aqui como developer.mozilla.org),
                        ou a porta port TCP (aqui indicada pelo 80 que é ocultado por ser o número da porta padrão)</li>
                    <li>A versão do protocolo HTTP.</li>
                    <li>Cabeçalhos opcionais que contém informações adicionais para os servidores.</li>
                    <li>Ou um corpo de dados, para alguns métodos como POST, similares aos corpos das respostas, que
                        contém o recurso requisitado.</li>
                </ul>
                <h4>Respostas</h4>
                <p>Examplo de resposta HTTP:</p>
                <img src="imgs/HTTP_Response.png" alt="" class="responsive-image">
                <p>Respostas consistem dos seguintes elementos:</p>
                <ul>
                    <li>A versão do protocolo HTTP que elas seguem.</li>
                    <li>Um código de status, indicando se a requisição foi bem sucedida, ou não, e por quê.</li>
                    <li>Uma mensagem de status, uma pequena descrição informal sobre o código de status.</li>
                    <li>Cabeçalhos HTTP, como aqueles das requisições.</li>
                    <li>Opcionalmente, um corpo com dados do recurso requisitado.</li>
                </ul>

                <div class="divider"></div>
                <h2>APIs baseadas no HTTP</h2>
                <p>A API mais utilizada construída em cima do HTTP é a XMLHttpRequest, que pode ser usada para trocar
                    dados entre um user agent e um servidor.</p>
                <p>Outra API, de eventos enviados pelo servidor, é um serviço de mão-única que permite um servidor
                    enviar eventos ao cliente, usando HTTP como um mecanismo de transporte. Usando a interface
                    EventSource, o cliente abre uma conexão e estabelece os manipuladores de evento. O navegador do
                    cliente converte automaticamente as mensagens que chegam pelo fluxo HTTP em objetos Event
                    apropriados, entregando-os aos manipuladores de evento que foram registrados para os tipos de
                    eventos type se conhecidos, ou para o manipulador de evento onmessage se nenhum manipulador de
                    evento específico ao tipo foi definido.</p>

                <div class="divider"></div>
                <h2>Conclusão</h2>
                <p>O HTTP é um protocolo extensível que é fácil de se usar. A arquitetura cliente-servidor, combinada
                    com a habilidade de simplesmente adicionar cabeçalhos, permite que o HTTP avance suas
                    funcionalidades juntamente com a elasticidade da Web.F</p>
                <p>Embora o HTTP/2.0 adicione mais complexidade, embutindo mensagens HTTP em quadros para melhorar a
                    performance, a estrutura básica das mensagens continua a mesma desde o HTTP/1.0. Fluxo de sessões
                    permanece simples, permitindo-o a ser investigado, e depurado com um simples monitor de mensagens
                    HTTP.</p>


            </div>
        </div>

    </div>
    <!-- Footer -->
    <div class="col ">

        <footer class="page-footer grey darken-3">
            <div class="container">
                <div class="row">
                    <div class="col l3 s12">
                        <h5 class="white-text">MDN web docs</h5>
                        <p class="grey-text text-lighten-4">moz://a</p>
                    </div>
                    <div class="col l2 offset-l2 s12">
                        <h5 class="white-text">MDN</h5>
                        <ul>
                            <li><a class="grey-text text-lighten-3" href="#!">Tecnologias web</a></li>
                            <li><a class="grey-text text-lighten-3" href="#!">Aprenda desenvolvimento web</a></li>
                            <li><a class="grey-text text-lighten-3" href="#!">Sobre a MDN</a></li>
                            <li><a class="grey-text text-lighten-3" href="#!">Comentários</a></li>
                        </ul>
                    </div>
                    <div class="col l2 offset-l2 s12 right">
                        <h5 class="white-text">Mozilla</h5>
                        <ul>
                            <li><a class="grey-text text-lighten-3" href="#!">Sobre</a></li>
                            <li><a class="grey-text text-lighten-3" href="#!">Fale conosco</a></li>
                            <li><a class="grey-text text-lighten-3" href="#!">Firefox</a></li>
                        </ul>
                    </div>
                </div>
            </div>
            <div class="footer-copyright grey darken-4">
                <div class="container" id="footerLinks">
                    © 2005-2019 Mozilla and individual contributors.Content is available under these licenses.
                    <a class="grey-text text-lighten-4 right" href="#!">Termos</a>
                    <a class="grey-text text-lighten-4 right" href="#!">Privacidade</a>
                    <a class="grey-text text-lighten-4 right" href="#!">Cookies</a>
                </div>
            </div>
        </footer>
    </div>




    <!-- Link JS -->
    <script type="text/javascript" src="js/jquery-1.11.3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js"></script>
    <script type="text/javascript" src="js/main.js"></script>
</body>

</html>